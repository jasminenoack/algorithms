<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Bubble Sort</title>
        <link rel="stylesheet" href="lib/highlight.default.css">
        <link rel="stylesheet" type="text/css" href="css/index2.css">
        <script src="lib/highlight.js"></script>
    </head>
    <body>
        <h2>Bubble Sort</h2>

        <p>
            Bubble sort is one of the most controversial sorting algorithms.
            It's extremely inefficent, and it has been argued, that it shouldn't be taught in CS courses.
            This is discussed more fully in <a href='https://users.cs.duke.edu/~ola/bubble/bubble.html'>Bubble Sort: An Archaeological Algorithmic Analysis</a>.
        </p>

        <div class="clear normal">
            <div class="left"><video src="videos/bubble-sort-base.mov" controls height=300 width=300></video></div>
            <p class="padding">
                This is a simple example of a bubble sort using a small random array.
                As you can see the sort compares each point to the point after it and swaps them if the second is smaller than the first.
                You can also see that this is a non-optimized version of the sort that continues attempting to sort after the array is already in order.
                This algorithm will always run at O(n<sup>2</sup>).
            </p>
        </div>

        <div class="normal">
            <video src="videos/bubble-sort-optimizations.mov" width="100%" controls></video>
            <p>
                This video shows a comparison of various optimizations of bubble sort.
                There are two common optimizations for Bubble Sort.
                One is called a short circuit.
                This means that if the array becomes ordered the sort will end.
                The second is to skip the sorted elements.
                Because of the way bubble sort works each round moves the highest value into the last position.
                The next round we do not have to recheck this final position.
                This video shows an unoptimized version, followed by a version using a short circuit,
                followed by a version that skips sorted elements, and lastly a version with both optimizations.
                Black nodes are nodes marked as sorted. Blue nodes are the nodes being compared.
            </p>
        </div>

        <div>
            <video src="videos/bubble-orders.mov" width="100%" controls></video>
            <p>
                This video compares Bubble Sort on different orders of points.
                These all use the most optimized version of the sort from above.
                It shows that the Sort is reasonably efficent on partially ordered sets,
                but on a reversed ordered set it has to run every comparison.
            </p>
        </div>


        <h4>How Bubble Sort Works</h4>

        <p>
            Bubble Sort is an exchange sort.
            It is named for the way that larger elements bubble up to the end of the list.
            The algorithm is very simple, but it is also very inefficent.
            There are various optimizations that can make bubble sort extremely efficient for almost sorted lists.
            However, other sorts exist have similar performance on ordered lists,
            and better performance on other orders.
        </p>

        <h4>Performance</h4>

        <p>
            Bubble sort has a worst-case complexity of O(n<sup>2</sup>) and an average case complexity of О(n<sup>2</sup>).
            If the sort is implemented with a short circuit for a presorted list there is a best case complexity of Ω(n).
        </p>

        <h4>Code Sample</h4>

        <h5>Python</h5>

        <pre><code class="python">
    def bubble_sort(nums):
        # Repeat the sort up to n - 1 times
        # if there are 5 elements. It will run the sort 4 times.
        # At minimum this will put 4 of the 5 elements in place.
        # And the array will become sorted.
        for i in range(1, len(nums)):
            # set a variable to check if the array is ordered
            ordered = True
            # For each round look at every number up to the second to last that has not been sorted.
            # We do not need to reconsider the final number of the previous round
            # because bubble sort always puts the highest number in the last position each round.
            for index in range(len(nums) - i):
                # compare each value to the next value in the array.
                # if the next value is smaller swap the values
                value = nums[index]
                next_value = nums[index + 1]
                if next_value < value:
                    nums[index], nums[index + 1] = next_value, value
                    # if you had to swap change the ordered variable
                    ordered = False
            # if the array was ordered break out of the loop
            if ordered:
                break
        # return the sorted array
        return nums
        </code></pre>

        <p><a href="https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort">See more</a></p>

        <p><a href="sort_comparison.html">Compare Yourself</a>

        <h4>Further Optimization</h4>

        <p>
            As I stated before Bubble Sort is an exceptionally poor sorting algorithm.
            It is not at all optimized and is problematic at best.
            But the simplicity of the algorithm does give some freedom to attempt
            new tactics and changes without a large issue.
            This may allow us to think about things that could improve the sort and
            may event help us to understand how alternative sorts might be derived from
            thinking about Bubble Sort.
        </p>

        <h5>Concurrency</h5>

        <p>
            One simple way to optimize is to process things concurrently.
            We will see other optimized sorts attempt this same method to
            speed up the sort.
            While there can be problems with concurrency in various languages
            we can see by simulating concurrency in javaScript why it seems to
            be a good solution to the problem of effeciency.
        </p>

        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
